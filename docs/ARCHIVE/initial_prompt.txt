(kopieren und in Claude Code oder Codex einfÃ¼gen)

System / Developer Prompt:
Ich mÃ¶chte eine React + TypeScript + Tailwind + Supabase App namens TradeMatrix.ai erstellen.
Sie soll lokal mit npm laufen und spÃ¤ter automatisch Ã¼ber Netlify deployen.
Erstelle mir das komplette Projekt mit folgender Struktur und Logik:

Module:
morningPlanner â†’ enthÃ¤lt Asia-Sweep & Y-Low-Rebound Strategien
usOpenPlanner â†’ Opening Range Breakout (ORB)
riskManager â†’ KO-Produkt-Logik (Berechnung Hebel, Distanz, Risiko)
journalBot â†’ speichert aktive Setups in Supabase

Pages:
dashboard (zeigt Morning-Setup & US-Setup JSONs an)
journal
alerts

Styling: Tailwind CSS, Dark-Mode (Matrix-Farben)

Integration: supabaseClient.ts mit Umgebungsvariablen aus .env

Startskripte: npm install, npm run dev

Baue die Datei-Struktur, initialisiere Vite (React + TS), installiere alle Pakete, richte Tailwind ein und erstelle Dummy-Funktionen in den Modulen, die die Logik simulieren.
AnschlieÃŸend soll die App auf localhost:5173 laufen und auf dem Dashboard die JSON-Outputs der Planner anzeigen.


Schritt 2: Datei-Erstellung
Claude Code (oder Codex) erstellt automatisch:

alle src/modules/*.ts
src/pages/*.tsx
tailwind.config.js
.env.example
package.json mit den nÃ¶tigen AbhÃ¤ngigkeiten

Wenn er nach Framework oder Builder fragt â†’ wÃ¤hle:

Vite
React + TypeScript
Tailwind


Schritt 3: Lokaler Test
Sobald alles generiert ist:
npm install
npm run dev

Dann Ã¶ffne:
ðŸ‘‰ http://localhost:5173
und du solltest im Dashboard deine JSON-Setups sehen (Morning & US Session).

Schritt 4: Git Push + Netlify
git init && git add . && git commit -m "init tradematrix.ai"
Repository zu GitHub pushen
In Netlify: Add New Site â†’ Import from Git â†’ Build Command: npm run build
Publish Directory: dist/

Wenn du mÃ¶chtest, kann ich dir den kompletten Claude-Prompt-Text fertig formatiert (copy-ready) liefern â€“ so, dass du ihn 1:1 in Claude einfÃ¼gen kannst und er alles automatisch erstellt.
Willst du, dass ich ihn dir so formatiere (mit ZeilenumbrÃ¼chen & farbcodierten Kommentaren)?

1) Datenquelle festlegen

PrimÃ¤r: Twelve Data (Realtime+Historical, WebSocket & REST)
Fallback (nur wenn nÃ¶tig): Yahoo (End-of-day), stock3 (Charts manuell).
Symbole (Beispiele):

DAX Kassa/CFD: DE40 (oder Anbieter-spezifisch)

Dow: DJI / US30

Nasdaq100: NDX / NAS100

Silber Spot: XAG/USD

Entscheidung heute: Wir nehmen Twelve Data fÃ¼r 1m/5m/15m/1h/1d OHLCV.

2) Credentials & Env

In Netlify/ lokal .env (keine SchlÃ¼ssel im Repo):

VITE_SUPABASE_URL

VITE_SUPABASE_KEY (anon)

SRV_SUPABASE_KEY (service role fÃ¼r Serverjobs)

TWELVE_DATA_KEY

3) Supabase â€“ Datenmodell (Tabellen & Policies)

Tabellen:

market_symbols
Felder: id, vendor, symbol, alias, tick_size, tz, active

ohlc (Intraday+Daily)
Felder: ts (UTC), symbol_id, tf (1m/5m/15m/1h/1d), open, high, low, close, volume
Indizes: (symbol_id, tf, ts); Retention: 1m/5m/15m 90 Tage, 1h/1d 2 Jahre

levels_daily (berechnete Levels)
Felder: trade_date, symbol_id, pivot, r1, r2, s1, s2, y_high, y_low, y_close

setups
Felder: id, created_at, module (morning/usopen), symbol_id, payload (JSON), status (pending/active/invalid/filled), confidence

alerts
Felder: id, created_at, symbol_id, kind (range_break/retest/... ), context (JSON), sent (bool)

journal
Felder: id, trade_date, symbol_id, setup_id, notes, outcome, rr, tags (array)

4) Ingestion-Pipeline (Serverseitig)

Edge Function / Scheduled Function (Netlify Scheduled Functions oder Supabase Cron):

Job A â€“ Historical Seed (einmalig je Symbol/TF): Hole 60â€“120 Tage OHLC fÃ¼r 1m/5m/15m/1h/1d â†’ schreibe in ohlc.

Job B â€“ Realtime Pull (laufend): Alle 60s (fÃ¼r 1m) â†’ REST pull fÃ¼r aktive Symbole & Zeitrahmen; alternativ WebSocket fÃ¼r Ticks, eigene Candle-Aggregation (nur wenn stabil).

Job C â€“ Daily Close (20:59â€“22:15 MEZ): Schreibe Y-High/Low/Close in levels_daily.

Timezone: Alle Timestamps in UTC speichern, Client/Logik rechnet auf Europe/Berlin.

5) Berechnungs-Jobs (serverseitige Logik, deterministisch)

Job D â€“ Levels/Pivots (tÃ¤glich 07:55 MEZ):
Nimmt Vortag aus ohlc(1d) â†’ berechnet pivot, r1, r2, s1, s2 â†’ speichert levels_daily.

Job E â€“ Session Windows:

EuropeOpen (08:00â€“10:00 MEZ): Quelle 1m/5m DAX

USOpen (15:30â€“17:30 MEZ): Quelle 1m/5m NASDAQ/DOW

6) Strategien als deterministische Server-Flows

MorningPlanner (08:25 MEZ Trigger):

Eingaben: ohlc 1m/5m (06:00â€“08:25), levels_daily von heute.

Regeln:

Asia Sweep â†’ EU Open Reversal: PrÃ¼fe 02:00â€“05:00 MEZ gegen y_low / y_high; wenn Bedingung erfÃ¼llt & Open > y_low (oder < y_high) â†’ Signal.

Y-Low â†’ Pivot Rebound: Wenn open < pivot und kein aktiver Breakout â†’ Entry-Zone [y_low..pivot], SL y_low - 0.25%, TP pivot â†’ r1.

Output: Ein setups-Eintrag pro Symbol (JSON mit Entry/SL/TP, Confidence, Status).

USOpenPlanner (15:25 MEZ Trigger):

Eingaben: 15:30â€“15:45 Kerzen auf 1m/5m/15m.

Regeln:

ORB: Markiere erste 15m Range; 5m Close Ã¼ber High â‡’ Long Bias (unter Low â‡’ Short). Entry-Modell Retest bevorzugt. SL = gegenÃ¼berliegende Range-Kante; TP = 2R oder Daily H/L.

Output: setups-Eintrag(e) fÃ¼r DOW/NASDAQ (+ optional DAX).

7) Alerts (Realtime â†’ Client)

AlertEngine (minÃ¼tlich / via Realtime):

Triggert auf:

range_break (ORB 5m Close Ã¼ber/unter 15m Range)

retest_touch (Preis kehrt zur Range-Kante zurÃ¼ck)

asia_sweep_confirmed (EU-Open Ã¼ber y_low)

pivot_touch / r1_touch / s1_touch

Schreibt alerts-Zeilen & setzt sent=false.

Client (Dashboard) subscribed auf alerts via Supabase Realtime â†’ zeigt Banner/Toast, setzt sent=true nach Anzeige.

8) Frontend â€“ Datennutzung (ohne Code, aber verbindlich)

Dashboard:

Pane â€žMorning Setupâ€œ: liest neuesten setups fÃ¼r DAX (status in {pending, active})

Pane â€žUS Open Setupâ€œ: dito fÃ¼r DOW/NASDAQ

Pane â€žAlerts Liveâ€œ: Realtime-Feed aus alerts

Pane â€žActive Levelsâ€œ: heutige levels_daily

Journal:

Liste aller setups mit Status und â€žPromote to Tradeâ€œ (manuell)

Notizenfeld â†’ journal schreiben

9) QualitÃ¤t & Tests

Daten-Checks:

LÃ¼ckenprÃ¼fung: pro Symbol/TF muss jede 1m Minute vorhanden sein; bei Gap â†’ Backfill-Job

Sanity: high>=max(open,close) und low<=min(open,close); Volumen â‰¥ 0

Performance: Indexe prÃ¼fen, Partitionierung optional (nach Monat)

Strategie-Backtests (Minimal):

Asia Sweep (30 Tage, DAX 5m): Erfolgsquote bis Pivot & bis Y-High

ORB (30 Sessions, NASDAQ 5m/1m): Quote Breakout vs. Retest, durchschnittliches R

10) Betrieb & Deployment

Netlify (Frontend):

Build: npm run build

Publish: dist/

ENV: VITE_* Variablen setzen

Server-Jobs:

Entweder Supabase Cron (SQL/Edge) oder Netlify Scheduled Functions im 1â€“5 Min Takt:

A: Seed (einmalig je Symbol/TF)

B: Realtime Pull (jede Minute)

C: Daily Close (abends)

D: Pivots (07:55)

MorningPlanner (08:25)

USOpenPlanner (15:25)

AlertEngine (jede Minute)

11) Abnahme-Kriterien (Definition of Done)

Daten: ohlc fÃ¼llt sich minÃ¼tlich fÃ¼r DAX/DOW/NASDAQ/XAGUSD (1m/5m/15m/1h/1d).

Levels: levels_daily korrekt um 07:55 MEZ.

Setups: zwei Records pro Tag (Morning & US), mit plausiblen Zonen.

Alerts: ORB-Break & Retest kommen live an, â€žsent=trueâ€œ nach Anzeige.

Dashboard: zeigt Setups + Alerts ohne Reload (Realtime).

Journal: Speichert manuelle Notiz zu aktivem Setup.